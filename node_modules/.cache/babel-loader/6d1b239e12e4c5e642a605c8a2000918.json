{"ast":null,"code":"var Rules = require('./rules');\n\nvar Lang = require('./lang');\n\nvar Errors = require('./errors');\n\nvar Attributes = require('./attributes');\n\nvar AsyncResolvers = require('./async');\n\nvar Validator = function (input, rules, customMessages) {\n  var lang = Validator.getDefaultLang();\n  this.input = input || {};\n  this.messages = Lang._make(lang);\n\n  this.messages._setCustom(customMessages);\n\n  this.setAttributeFormatter(Validator.prototype.attributeFormatter);\n  this.errors = new Errors();\n  this.errorCount = 0;\n  this.hasAsync = false;\n  this.rules = this._parseRules(rules);\n};\n\nValidator.prototype = {\n  constructor: Validator,\n\n  /**\n   * Default language\n   *\n   * @type {string}\n   */\n  lang: 'en',\n\n  /**\n   * Numeric based rules\n   *\n   * @type {array}\n   */\n  numericRules: ['integer', 'numeric'],\n\n  /**\n   * Attribute formatter.\n   *\n   * @type {function}\n   */\n  attributeFormatter: Attributes.formatter,\n\n  /**\n   * Run validator\n   *\n   * @return {boolean} Whether it passes; true = passes, false = fails\n   */\n  check: function () {\n    var self = this;\n\n    for (var attribute in this.rules) {\n      var attributeRules = this.rules[attribute];\n\n      var inputValue = this._objectPath(this.input, attribute);\n\n      if (this._hasRule(attribute, ['sometimes']) && !this._suppliedWithData(attribute)) {\n        continue;\n      }\n\n      for (var i = 0, len = attributeRules.length, rule, ruleOptions, rulePassed; i < len; i++) {\n        ruleOptions = attributeRules[i];\n        rule = this.getRule(ruleOptions.name);\n\n        if (!this._isValidatable(rule, inputValue)) {\n          continue;\n        }\n\n        rulePassed = rule.validate(inputValue, ruleOptions.value, attribute);\n\n        if (!rulePassed) {\n          this._addFailure(rule);\n        }\n\n        if (this._shouldStopValidating(attribute, rulePassed)) {\n          break;\n        }\n      }\n    }\n\n    return this.errorCount === 0;\n  },\n\n  /**\n   * Run async validator\n   *\n   * @param {function} passes\n   * @param {function} fails\n   * @return {void}\n   */\n  checkAsync: function (passes, fails) {\n    var _this = this;\n\n    passes = passes || function () {};\n\n    fails = fails || function () {};\n\n    var failsOne = function (rule, message) {\n      _this._addFailure(rule, message);\n    };\n\n    var resolvedAll = function (allPassed) {\n      if (allPassed) {\n        passes();\n      } else {\n        fails();\n      }\n    };\n\n    var asyncResolvers = new AsyncResolvers(failsOne, resolvedAll);\n\n    var validateRule = function (inputValue, ruleOptions, attribute, rule) {\n      return function () {\n        var resolverIndex = asyncResolvers.add(rule);\n        rule.validate(inputValue, ruleOptions.value, attribute, function () {\n          asyncResolvers.resolve(resolverIndex);\n        });\n      };\n    };\n\n    for (var attribute in this.rules) {\n      var attributeRules = this.rules[attribute];\n\n      var inputValue = this._objectPath(this.input, attribute);\n\n      if (this._hasRule(attribute, ['sometimes']) && !this._suppliedWithData(attribute)) {\n        continue;\n      }\n\n      for (var i = 0, len = attributeRules.length, rule, ruleOptions; i < len; i++) {\n        ruleOptions = attributeRules[i];\n        rule = this.getRule(ruleOptions.name);\n\n        if (!this._isValidatable(rule, inputValue)) {\n          continue;\n        }\n\n        validateRule(inputValue, ruleOptions, attribute, rule)();\n      }\n    }\n\n    asyncResolvers.enableFiring();\n    asyncResolvers.fire();\n  },\n\n  /**\n   * Add failure and error message for given rule\n   *\n   * @param {Rule} rule\n   */\n  _addFailure: function (rule) {\n    var msg = this.messages.render(rule);\n    this.errors.add(rule.attribute, msg);\n    this.errorCount++;\n  },\n\n  /**\n   * Flatten nested object, normalizing { foo: { bar: 1 } } into: { 'foo.bar': 1 }\n   *\n   * @param  {object} nested object\n   * @return {object} flattened object\n   */\n  _flattenObject: function (obj) {\n    var flattened = {};\n\n    function recurse(current, property) {\n      if (!property && Object.getOwnPropertyNames(current).length === 0) {\n        return;\n      }\n\n      if (Object(current) !== current || Array.isArray(current)) {\n        flattened[property] = current;\n      } else {\n        var isEmpty = true;\n\n        for (var p in current) {\n          isEmpty = false;\n          recurse(current[p], property ? property + '.' + p : p);\n        }\n\n        if (isEmpty) {\n          flattened[property] = {};\n        }\n      }\n    }\n\n    if (obj) {\n      recurse(obj);\n    }\n\n    return flattened;\n  },\n\n  /**\n   * Extract value from nested object using string path with dot notation\n   *\n   * @param  {object} object to search in\n   * @param  {string} path inside object\n   * @return {any|void} value under the path\n   */\n  _objectPath: function (obj, path) {\n    if (Object.prototype.hasOwnProperty.call(obj, path)) {\n      return obj[path];\n    }\n\n    var keys = path.replace(/\\[(\\w+)\\]/g, '.$1').replace(/^\\./, '').split('.');\n    var copy = {};\n\n    for (var attr in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, attr)) {\n        copy[attr] = obj[attr];\n      }\n    }\n\n    for (var i = 0, l = keys.length; i < l; i++) {\n      if (typeof copy === 'object' && copy !== null && Object.hasOwnProperty.call(copy, keys[i])) {\n        copy = copy[keys[i]];\n      } else {\n        return;\n      }\n    }\n\n    return copy;\n  },\n\n  /**\n   * Parse rules, normalizing format into: { attribute: [{ name: 'age', value: 3 }] }\n   *\n   * @param  {object} rules\n   * @return {object}\n   */\n  _parseRules: function (rules) {\n    var parsedRules = {};\n    rules = this._flattenObject(rules);\n\n    for (var attribute in rules) {\n      var rulesArray = rules[attribute];\n\n      this._parseRulesCheck(attribute, rulesArray, parsedRules);\n    }\n\n    return parsedRules;\n  },\n  _parseRulesCheck: function (attribute, rulesArray, parsedRules, wildCardValues) {\n    if (attribute.indexOf('*') > -1) {\n      this._parsedRulesRecurse(attribute, rulesArray, parsedRules, wildCardValues);\n    } else {\n      this._parseRulesDefault(attribute, rulesArray, parsedRules, wildCardValues);\n    }\n  },\n  _parsedRulesRecurse: function (attribute, rulesArray, parsedRules, wildCardValues) {\n    var parentPath = attribute.substr(0, attribute.indexOf('*') - 1);\n\n    var propertyValue = this._objectPath(this.input, parentPath);\n\n    if (propertyValue) {\n      for (var propertyNumber = 0; propertyNumber < propertyValue.length; propertyNumber++) {\n        var workingValues = wildCardValues ? wildCardValues.slice() : [];\n        workingValues.push(propertyNumber);\n\n        this._parseRulesCheck(attribute.replace('*', propertyNumber), rulesArray, parsedRules, workingValues);\n      }\n    }\n  },\n  _parseRulesDefault: function (attribute, rulesArray, parsedRules, wildCardValues) {\n    var attributeRules = [];\n\n    if (rulesArray instanceof Array) {\n      rulesArray = this._prepareRulesArray(rulesArray);\n    }\n\n    if (typeof rulesArray === 'string') {\n      rulesArray = rulesArray.split('|');\n    }\n\n    for (var i = 0, len = rulesArray.length, rule; i < len; i++) {\n      rule = typeof rulesArray[i] === 'string' ? this._extractRuleAndRuleValue(rulesArray[i]) : rulesArray[i];\n\n      if (rule.value) {\n        rule.value = this._replaceWildCards(rule.value, wildCardValues);\n\n        this._replaceWildCardsMessages(wildCardValues);\n      }\n\n      if (Rules.isAsync(rule.name)) {\n        this.hasAsync = true;\n      }\n\n      attributeRules.push(rule);\n    }\n\n    parsedRules[attribute] = attributeRules;\n  },\n  _replaceWildCards: function (path, nums) {\n    if (!nums) {\n      return path;\n    }\n\n    var path2 = path;\n    nums.forEach(function (value) {\n      if (Array.isArray(path2)) {\n        path2 = path2[0];\n      }\n\n      const pos = path2.indexOf('*');\n\n      if (pos === -1) {\n        return path2;\n      }\n\n      path2 = path2.substr(0, pos) + value + path2.substr(pos + 1);\n    });\n\n    if (Array.isArray(path)) {\n      path[0] = path2;\n      path2 = path;\n    }\n\n    return path2;\n  },\n  _replaceWildCardsMessages: function (nums) {\n    var customMessages = this.messages.customMessages;\n    var self = this;\n    Object.keys(customMessages).forEach(function (key) {\n      if (nums) {\n        var newKey = self._replaceWildCards(key, nums);\n\n        customMessages[newKey] = customMessages[key];\n      }\n    });\n\n    this.messages._setCustom(customMessages);\n  },\n\n  /**\n   * Prepare rules if it comes in Array. Check for objects. Need for type validation.\n   *\n   * @param  {array} rulesArray\n   * @return {array}\n   */\n  _prepareRulesArray: function (rulesArray) {\n    var rules = [];\n\n    for (var i = 0, len = rulesArray.length; i < len; i++) {\n      if (typeof rulesArray[i] === 'object') {\n        for (var rule in rulesArray[i]) {\n          rules.push({\n            name: rule,\n            value: rulesArray[i][rule]\n          });\n        }\n      } else {\n        rules.push(rulesArray[i]);\n      }\n    }\n\n    return rules;\n  },\n\n  /**\n   * Determines if the attribute is supplied with the original data object.\n   *\n   * @param  {array} attribute\n   * @return {boolean}\n   */\n  _suppliedWithData: function (attribute) {\n    return this.input.hasOwnProperty(attribute);\n  },\n\n  /**\n   * Extract a rule and a value from a ruleString (i.e. min:3), rule = min, value = 3\n   *\n   * @param  {string} ruleString min:3\n   * @return {object} object containing the name of the rule and value\n   */\n  _extractRuleAndRuleValue: function (ruleString) {\n    var rule = {},\n        ruleArray;\n    rule.name = ruleString;\n\n    if (ruleString.indexOf(':') >= 0) {\n      ruleArray = ruleString.split(':');\n      rule.name = ruleArray[0];\n      rule.value = ruleArray.slice(1).join(':');\n    }\n\n    return rule;\n  },\n\n  /**\n   * Determine if attribute has any of the given rules\n   *\n   * @param  {string}  attribute\n   * @param  {array}   findRules\n   * @return {boolean}\n   */\n  _hasRule: function (attribute, findRules) {\n    var rules = this.rules[attribute] || [];\n\n    for (var i = 0, len = rules.length; i < len; i++) {\n      if (findRules.indexOf(rules[i].name) > -1) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * Determine if attribute has any numeric-based rules.\n   *\n   * @param  {string}  attribute\n   * @return {Boolean}\n   */\n  _hasNumericRule: function (attribute) {\n    return this._hasRule(attribute, this.numericRules);\n  },\n\n  /**\n   * Determine if rule is validatable\n   *\n   * @param  {Rule}   rule\n   * @param  {mixed}  value\n   * @return {boolean}\n   */\n  _isValidatable: function (rule, value) {\n    if (Array.isArray(value)) {\n      return true;\n    }\n\n    if (Rules.isImplicit(rule.name)) {\n      return true;\n    }\n\n    return this.getRule('required').validate(value);\n  },\n\n  /**\n   * Determine if we should stop validating.\n   *\n   * @param  {string} attribute\n   * @param  {boolean} rulePassed\n   * @return {boolean}\n   */\n  _shouldStopValidating: function (attribute, rulePassed) {\n    var stopOnAttributes = this.stopOnAttributes;\n\n    if (typeof stopOnAttributes === 'undefined' || stopOnAttributes === false || rulePassed === true) {\n      return false;\n    }\n\n    if (stopOnAttributes instanceof Array) {\n      return stopOnAttributes.indexOf(attribute) > -1;\n    }\n\n    return true;\n  },\n\n  /**\n   * Set custom attribute names.\n   *\n   * @param {object} attributes\n   * @return {void}\n   */\n  setAttributeNames: function (attributes) {\n    this.messages._setAttributeNames(attributes);\n  },\n\n  /**\n   * Set the attribute formatter.\n   *\n   * @param {fuction} func\n   * @return {void}\n   */\n  setAttributeFormatter: function (func) {\n    this.messages._setAttributeFormatter(func);\n  },\n\n  /**\n   * Get validation rule\n   *\n   * @param  {string} name\n   * @return {Rule}\n   */\n  getRule: function (name) {\n    return Rules.make(name, this);\n  },\n\n  /**\n   * Stop on first error.\n   *\n   * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.\n   * @return {void}\n   */\n  stopOnError: function (attributes) {\n    this.stopOnAttributes = attributes;\n  },\n\n  /**\n   * Determine if validation passes\n   *\n   * @param {function} passes\n   * @return {boolean|undefined}\n   */\n  passes: function (passes) {\n    var async = this._checkAsync('passes', passes);\n\n    if (async) {\n      return this.checkAsync(passes);\n    }\n\n    return this.check();\n  },\n\n  /**\n   * Determine if validation fails\n   *\n   * @param {function} fails\n   * @return {boolean|undefined}\n   */\n  fails: function (fails) {\n    var async = this._checkAsync('fails', fails);\n\n    if (async) {\n      return this.checkAsync(function () {}, fails);\n    }\n\n    return !this.check();\n  },\n\n  /**\n   * Check if validation should be called asynchronously\n   *\n   * @param  {string}   funcName Name of the caller\n   * @param  {function} callback\n   * @return {boolean}\n   */\n  _checkAsync: function (funcName, callback) {\n    var hasCallback = typeof callback === 'function';\n\n    if (this.hasAsync && !hasCallback) {\n      throw funcName + ' expects a callback when async rules are being tested.';\n    }\n\n    return this.hasAsync || hasCallback;\n  }\n};\n/**\n * Set messages for language\n *\n * @param {string} lang\n * @param {object} messages\n * @return {this}\n */\n\nValidator.setMessages = function (lang, messages) {\n  Lang._set(lang, messages);\n\n  return this;\n};\n/**\n * Get messages for given language\n *\n * @param  {string} lang\n * @return {Messages}\n */\n\n\nValidator.getMessages = function (lang) {\n  return Lang._get(lang);\n};\n/**\n * Set default language to use\n *\n * @param {string} lang\n * @return {void}\n */\n\n\nValidator.useLang = function (lang) {\n  this.prototype.lang = lang;\n};\n/**\n * Get default language\n *\n * @return {string}\n */\n\n\nValidator.getDefaultLang = function () {\n  return this.prototype.lang;\n};\n/**\n * Set the attribute formatter.\n *\n * @param {fuction} func\n * @return {void}\n */\n\n\nValidator.setAttributeFormatter = function (func) {\n  this.prototype.attributeFormatter = func;\n};\n/**\n * Stop on first error.\n *\n * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.\n * @return {void}\n */\n\n\nValidator.stopOnError = function (attributes) {\n  this.prototype.stopOnAttributes = attributes;\n};\n/**\n * Register custom validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\n\n\nValidator.register = function (name, fn, message, fnReplacement) {\n  var lang = Validator.getDefaultLang();\n  Rules.register(name, fn);\n\n  Lang._setRuleMessage(lang, name, message);\n};\n/**\n * Register custom validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @param  {function} fnReplacement\n * @return {void}\n */\n\n\nValidator.registerImplicit = function (name, fn, message, fnReplacement) {\n  var lang = Validator.getDefaultLang();\n  Rules.registerImplicit(name, fn);\n\n  Lang._setRuleMessage(lang, name, message);\n};\n/**\n * Register asynchronous validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\n\n\nValidator.registerAsync = function (name, fn, message, fnReplacement) {\n  var lang = Validator.getDefaultLang();\n  Rules.registerAsync(name, fn);\n\n  Lang._setRuleMessage(lang, name, message);\n};\n/**\n * Register asynchronous validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\n\n\nValidator.registerAsyncImplicit = function (name, fn, message) {\n  var lang = Validator.getDefaultLang();\n  Rules.registerAsyncImplicit(name, fn);\n\n  Lang._setRuleMessage(lang, name, message);\n};\n/**\n * Register validator for missed validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\n\n\nValidator.registerMissedRuleValidator = function (fn, message) {\n  Rules.registerMissedRuleValidator(fn, message);\n};\n\nmodule.exports = Validator;","map":{"version":3,"names":["Rules","require","Lang","Errors","Attributes","AsyncResolvers","Validator","input","rules","customMessages","lang","getDefaultLang","messages","_make","_setCustom","setAttributeFormatter","prototype","attributeFormatter","errors","errorCount","hasAsync","_parseRules","constructor","numericRules","formatter","check","self","attribute","attributeRules","inputValue","_objectPath","_hasRule","_suppliedWithData","i","len","length","rule","ruleOptions","rulePassed","getRule","name","_isValidatable","validate","value","_addFailure","_shouldStopValidating","checkAsync","passes","fails","_this","failsOne","message","resolvedAll","allPassed","asyncResolvers","validateRule","resolverIndex","add","resolve","enableFiring","fire","msg","render","_flattenObject","obj","flattened","recurse","current","property","Object","getOwnPropertyNames","Array","isArray","isEmpty","p","path","hasOwnProperty","call","keys","replace","split","copy","attr","l","parsedRules","rulesArray","_parseRulesCheck","wildCardValues","indexOf","_parsedRulesRecurse","_parseRulesDefault","parentPath","substr","propertyValue","propertyNumber","workingValues","slice","push","_prepareRulesArray","_extractRuleAndRuleValue","_replaceWildCards","_replaceWildCardsMessages","isAsync","nums","path2","forEach","pos","key","newKey","ruleString","ruleArray","join","findRules","_hasNumericRule","isImplicit","stopOnAttributes","setAttributeNames","attributes","_setAttributeNames","func","_setAttributeFormatter","make","stopOnError","async","_checkAsync","funcName","callback","hasCallback","setMessages","_set","getMessages","_get","useLang","register","fn","fnReplacement","_setRuleMessage","registerImplicit","registerAsync","registerAsyncImplicit","registerMissedRuleValidator","module","exports"],"sources":["/home/rnrifai/Documents/Eduwork/tugas-react-master/node_modules/validatorjs/src/validator.js"],"sourcesContent":["var Rules = require('./rules');\nvar Lang = require('./lang');\nvar Errors = require('./errors');\nvar Attributes = require('./attributes');\nvar AsyncResolvers = require('./async');\n\nvar Validator = function (input, rules, customMessages) {\n  var lang = Validator.getDefaultLang();\n  this.input = input || {};\n\n  this.messages = Lang._make(lang);\n  this.messages._setCustom(customMessages);\n  this.setAttributeFormatter(Validator.prototype.attributeFormatter);\n\n  this.errors = new Errors();\n  this.errorCount = 0;\n\n  this.hasAsync = false;\n  this.rules = this._parseRules(rules);\n};\n\nValidator.prototype = {\n\n  constructor: Validator,\n\n  /**\n   * Default language\n   *\n   * @type {string}\n   */\n  lang: 'en',\n\n  /**\n   * Numeric based rules\n   *\n   * @type {array}\n   */\n  numericRules: ['integer', 'numeric'],\n\n  /**\n   * Attribute formatter.\n   *\n   * @type {function}\n   */\n  attributeFormatter: Attributes.formatter,\n\n  /**\n   * Run validator\n   *\n   * @return {boolean} Whether it passes; true = passes, false = fails\n   */\n  check: function () {\n    var self = this;\n\n    for (var attribute in this.rules) {\n      var attributeRules = this.rules[attribute];\n      var inputValue = this._objectPath(this.input, attribute);\n\n      if (this._hasRule(attribute, ['sometimes']) && !this._suppliedWithData(attribute)) {\n        continue;\n      }\n\n      for (var i = 0, len = attributeRules.length, rule, ruleOptions, rulePassed; i < len; i++) {\n        ruleOptions = attributeRules[i];\n        rule = this.getRule(ruleOptions.name);\n\n        if (!this._isValidatable(rule, inputValue)) {\n          continue;\n        }\n\n        rulePassed = rule.validate(inputValue, ruleOptions.value, attribute);\n        if (!rulePassed) {\n          this._addFailure(rule);\n        }\n\n        if (this._shouldStopValidating(attribute, rulePassed)) {\n          break;\n        }\n      }\n    }\n\n    return this.errorCount === 0;\n  },\n\n  /**\n   * Run async validator\n   *\n   * @param {function} passes\n   * @param {function} fails\n   * @return {void}\n   */\n  checkAsync: function (passes, fails) {\n    var _this = this;\n    passes = passes || function () {};\n    fails = fails || function () {};\n\n    var failsOne = function (rule, message) {\n      _this._addFailure(rule, message);\n    };\n\n    var resolvedAll = function (allPassed) {\n      if (allPassed) {\n        passes();\n      } else {\n        fails();\n      }\n    };\n\n    var asyncResolvers = new AsyncResolvers(failsOne, resolvedAll);\n\n    var validateRule = function (inputValue, ruleOptions, attribute, rule) {\n      return function () {\n        var resolverIndex = asyncResolvers.add(rule);\n        rule.validate(inputValue, ruleOptions.value, attribute, function () {\n          asyncResolvers.resolve(resolverIndex);\n        });\n      };\n    };\n\n    for (var attribute in this.rules) {\n      var attributeRules = this.rules[attribute];\n      var inputValue = this._objectPath(this.input, attribute);\n\n      if (this._hasRule(attribute, ['sometimes']) && !this._suppliedWithData(attribute)) {\n        continue;\n      }\n\n      for (var i = 0, len = attributeRules.length, rule, ruleOptions; i < len; i++) {\n        ruleOptions = attributeRules[i];\n\n        rule = this.getRule(ruleOptions.name);\n\n        if (!this._isValidatable(rule, inputValue)) {\n          continue;\n        }\n\n        validateRule(inputValue, ruleOptions, attribute, rule)();\n      }\n    }\n\n    asyncResolvers.enableFiring();\n    asyncResolvers.fire();\n  },\n\n  /**\n   * Add failure and error message for given rule\n   *\n   * @param {Rule} rule\n   */\n  _addFailure: function (rule) {\n    var msg = this.messages.render(rule);\n    this.errors.add(rule.attribute, msg);\n    this.errorCount++;\n  },\n\n  /**\n   * Flatten nested object, normalizing { foo: { bar: 1 } } into: { 'foo.bar': 1 }\n   *\n   * @param  {object} nested object\n   * @return {object} flattened object\n   */\n  _flattenObject: function (obj) {\n    var flattened = {};\n\n    function recurse(current, property) {\n      if (!property && Object.getOwnPropertyNames(current).length === 0) {\n        return;\n      }\n      if (Object(current) !== current || Array.isArray(current)) {\n        flattened[property] = current;\n      } else {\n        var isEmpty = true;\n        for (var p in current) {\n          isEmpty = false;\n          recurse(current[p], property ? property + '.' + p : p);\n        }\n        if (isEmpty) {\n          flattened[property] = {};\n        }\n      }\n    }\n    if (obj) {\n      recurse(obj);\n    }\n    return flattened;\n  },\n\n  /**\n   * Extract value from nested object using string path with dot notation\n   *\n   * @param  {object} object to search in\n   * @param  {string} path inside object\n   * @return {any|void} value under the path\n   */\n  _objectPath: function (obj, path) {\n    if (Object.prototype.hasOwnProperty.call(obj, path)) {\n      return obj[path];\n    }\n\n    var keys = path.replace(/\\[(\\w+)\\]/g, '.$1').replace(/^\\./, '').split('.');\n    var copy = {};\n    for (var attr in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, attr)) {\n        copy[attr] = obj[attr];\n      }\n    }\n\n    for (var i = 0, l = keys.length; i < l; i++) {\n      if (typeof copy === 'object' && copy !== null && Object.hasOwnProperty.call(copy, keys[i])) {\n        copy = copy[keys[i]];\n      } else {\n        return;\n      }\n    }\n    return copy;\n  },\n\n  /**\n   * Parse rules, normalizing format into: { attribute: [{ name: 'age', value: 3 }] }\n   *\n   * @param  {object} rules\n   * @return {object}\n   */\n  _parseRules: function (rules) {\n\n    var parsedRules = {};\n    rules = this._flattenObject(rules);\n\n    for (var attribute in rules) {\n\n      var rulesArray = rules[attribute];\n\n      this._parseRulesCheck(attribute, rulesArray, parsedRules);\n    }\n    return parsedRules;\n\n\n  },\n\n  _parseRulesCheck: function (attribute, rulesArray, parsedRules, wildCardValues) {\n    if (attribute.indexOf('*') > -1) {\n      this._parsedRulesRecurse(attribute, rulesArray, parsedRules, wildCardValues);\n    } else {\n      this._parseRulesDefault(attribute, rulesArray, parsedRules, wildCardValues);\n    }\n  },\n\n  _parsedRulesRecurse: function (attribute, rulesArray, parsedRules, wildCardValues) {\n    var parentPath = attribute.substr(0, attribute.indexOf('*') - 1);\n    var propertyValue = this._objectPath(this.input, parentPath);\n\n    if (propertyValue) {\n      for (var propertyNumber = 0; propertyNumber < propertyValue.length; propertyNumber++) {\n        var workingValues = wildCardValues ? wildCardValues.slice() : [];\n        workingValues.push(propertyNumber);\n        this._parseRulesCheck(attribute.replace('*', propertyNumber), rulesArray, parsedRules, workingValues);\n      }\n    }\n  },\n\n  _parseRulesDefault: function (attribute, rulesArray, parsedRules, wildCardValues) {\n    var attributeRules = [];\n\n    if (rulesArray instanceof Array) {\n      rulesArray = this._prepareRulesArray(rulesArray);\n    }\n\n    if (typeof rulesArray === 'string') {\n      rulesArray = rulesArray.split('|');\n    }\n\n    for (var i = 0, len = rulesArray.length, rule; i < len; i++) {\n      rule = typeof rulesArray[i] === 'string' ? this._extractRuleAndRuleValue(rulesArray[i]) : rulesArray[i];\n      if (rule.value) {\n        rule.value = this._replaceWildCards(rule.value, wildCardValues);\n        this._replaceWildCardsMessages(wildCardValues);\n      }\n\n      if (Rules.isAsync(rule.name)) {\n        this.hasAsync = true;\n      }\n      attributeRules.push(rule);\n    }\n\n    parsedRules[attribute] = attributeRules;\n  },\n\n  _replaceWildCards: function (path, nums) {\n\n    if (!nums) {\n      return path;\n    }\n\n    var path2 = path;\n    nums.forEach(function (value) {\n      if(Array.isArray(path2)){\n        path2 = path2[0];\n      }\n      const pos = path2.indexOf('*');\n      if (pos === -1) {\n        return path2;\n      }\n      path2 = path2.substr(0, pos) + value + path2.substr(pos + 1);\n    });\n    if(Array.isArray(path)){\n      path[0] = path2;\n      path2 = path;\n    }\n    return path2;\n  },\n\n  _replaceWildCardsMessages: function (nums) {\n    var customMessages = this.messages.customMessages;\n    var self = this;\n    Object.keys(customMessages).forEach(function (key) {\n      if (nums) {\n        var newKey = self._replaceWildCards(key, nums);\n        customMessages[newKey] = customMessages[key];\n      }\n    });\n\n    this.messages._setCustom(customMessages);\n  },\n  /**\n   * Prepare rules if it comes in Array. Check for objects. Need for type validation.\n   *\n   * @param  {array} rulesArray\n   * @return {array}\n   */\n  _prepareRulesArray: function (rulesArray) {\n    var rules = [];\n\n    for (var i = 0, len = rulesArray.length; i < len; i++) {\n      if (typeof rulesArray[i] === 'object') {\n        for (var rule in rulesArray[i]) {\n          rules.push({\n            name: rule,\n            value: rulesArray[i][rule]\n          });\n        }\n      } else {\n        rules.push(rulesArray[i]);\n      }\n    }\n\n    return rules;\n  },\n\n  /**\n   * Determines if the attribute is supplied with the original data object.\n   *\n   * @param  {array} attribute\n   * @return {boolean}\n   */\n  _suppliedWithData: function (attribute) {\n    return this.input.hasOwnProperty(attribute);\n  },\n\n  /**\n   * Extract a rule and a value from a ruleString (i.e. min:3), rule = min, value = 3\n   *\n   * @param  {string} ruleString min:3\n   * @return {object} object containing the name of the rule and value\n   */\n  _extractRuleAndRuleValue: function (ruleString) {\n    var rule = {},\n      ruleArray;\n\n    rule.name = ruleString;\n\n    if (ruleString.indexOf(':') >= 0) {\n      ruleArray = ruleString.split(':');\n      rule.name = ruleArray[0];\n      rule.value = ruleArray.slice(1).join(':');\n    }\n\n    return rule;\n  },\n\n  /**\n   * Determine if attribute has any of the given rules\n   *\n   * @param  {string}  attribute\n   * @param  {array}   findRules\n   * @return {boolean}\n   */\n  _hasRule: function (attribute, findRules) {\n    var rules = this.rules[attribute] || [];\n    for (var i = 0, len = rules.length; i < len; i++) {\n      if (findRules.indexOf(rules[i].name) > -1) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  /**\n   * Determine if attribute has any numeric-based rules.\n   *\n   * @param  {string}  attribute\n   * @return {Boolean}\n   */\n  _hasNumericRule: function (attribute) {\n    return this._hasRule(attribute, this.numericRules);\n  },\n\n  /**\n   * Determine if rule is validatable\n   *\n   * @param  {Rule}   rule\n   * @param  {mixed}  value\n   * @return {boolean}\n   */\n  _isValidatable: function (rule, value) {\n    if (Array.isArray(value)) {\n      return true;\n    }\n    if (Rules.isImplicit(rule.name)) {\n      return true;\n    }\n\n    return this.getRule('required').validate(value);\n  },\n\n  /**\n   * Determine if we should stop validating.\n   *\n   * @param  {string} attribute\n   * @param  {boolean} rulePassed\n   * @return {boolean}\n   */\n  _shouldStopValidating: function (attribute, rulePassed) {\n\n    var stopOnAttributes = this.stopOnAttributes;\n    if (typeof stopOnAttributes === 'undefined' || stopOnAttributes === false || rulePassed === true) {\n      return false;\n    }\n\n    if (stopOnAttributes instanceof Array) {\n      return stopOnAttributes.indexOf(attribute) > -1;\n    }\n\n    return true;\n  },\n\n  /**\n   * Set custom attribute names.\n   *\n   * @param {object} attributes\n   * @return {void}\n   */\n  setAttributeNames: function (attributes) {\n    this.messages._setAttributeNames(attributes);\n  },\n\n  /**\n   * Set the attribute formatter.\n   *\n   * @param {fuction} func\n   * @return {void}\n   */\n  setAttributeFormatter: function (func) {\n    this.messages._setAttributeFormatter(func);\n  },\n\n  /**\n   * Get validation rule\n   *\n   * @param  {string} name\n   * @return {Rule}\n   */\n  getRule: function (name) {\n    return Rules.make(name, this);\n  },\n\n  /**\n   * Stop on first error.\n   *\n   * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.\n   * @return {void}\n   */\n  stopOnError: function (attributes) {\n    this.stopOnAttributes = attributes;\n  },\n\n  /**\n   * Determine if validation passes\n   *\n   * @param {function} passes\n   * @return {boolean|undefined}\n   */\n  passes: function (passes) {\n    var async = this._checkAsync('passes', passes);\n    if (async) {\n      return this.checkAsync(passes);\n    }\n    return this.check();\n  },\n\n  /**\n   * Determine if validation fails\n   *\n   * @param {function} fails\n   * @return {boolean|undefined}\n   */\n  fails: function (fails) {\n    var async = this._checkAsync('fails', fails);\n    if (async) {\n      return this.checkAsync(function () {}, fails);\n    }\n    return !this.check();\n  },\n\n  /**\n   * Check if validation should be called asynchronously\n   *\n   * @param  {string}   funcName Name of the caller\n   * @param  {function} callback\n   * @return {boolean}\n   */\n  _checkAsync: function (funcName, callback) {\n    var hasCallback = typeof callback === 'function';\n    if (this.hasAsync && !hasCallback) {\n      throw funcName + ' expects a callback when async rules are being tested.';\n    }\n\n    return this.hasAsync || hasCallback;\n  }\n\n};\n\n/**\n * Set messages for language\n *\n * @param {string} lang\n * @param {object} messages\n * @return {this}\n */\nValidator.setMessages = function (lang, messages) {\n  Lang._set(lang, messages);\n  return this;\n};\n\n/**\n * Get messages for given language\n *\n * @param  {string} lang\n * @return {Messages}\n */\nValidator.getMessages = function (lang) {\n  return Lang._get(lang);\n};\n\n/**\n * Set default language to use\n *\n * @param {string} lang\n * @return {void}\n */\nValidator.useLang = function (lang) {\n  this.prototype.lang = lang;\n};\n\n/**\n * Get default language\n *\n * @return {string}\n */\nValidator.getDefaultLang = function () {\n  return this.prototype.lang;\n};\n\n/**\n * Set the attribute formatter.\n *\n * @param {fuction} func\n * @return {void}\n */\nValidator.setAttributeFormatter = function (func) {\n  this.prototype.attributeFormatter = func;\n};\n\n/**\n * Stop on first error.\n *\n * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.\n * @return {void}\n */\nValidator.stopOnError = function (attributes) {\n  this.prototype.stopOnAttributes = attributes;\n};\n\n/**\n * Register custom validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\nValidator.register = function (name, fn, message, fnReplacement) {\n  var lang = Validator.getDefaultLang();\n  Rules.register(name, fn);\n  Lang._setRuleMessage(lang, name, message);\n};\n\n/**\n * Register custom validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @param  {function} fnReplacement\n * @return {void}\n */\nValidator.registerImplicit = function (name, fn, message, fnReplacement) {\n  var lang = Validator.getDefaultLang();\n  Rules.registerImplicit(name, fn);\n  Lang._setRuleMessage(lang, name, message);\n};\n\n/**\n * Register asynchronous validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\nValidator.registerAsync = function (name, fn, message, fnReplacement) {\n  var lang = Validator.getDefaultLang();\n  Rules.registerAsync(name, fn);\n  Lang._setRuleMessage(lang, name, message);\n};\n\n/**\n * Register asynchronous validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\nValidator.registerAsyncImplicit = function (name, fn, message) {\n  var lang = Validator.getDefaultLang();\n  Rules.registerAsyncImplicit(name, fn);\n  Lang._setRuleMessage(lang, name, message);\n};\n\n/**\n * Register validator for missed validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\nValidator.registerMissedRuleValidator = function(fn, message) {\n  Rules.registerMissedRuleValidator(fn, message);\n};\n\nmodule.exports = Validator;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}